// Code generated by github.com/firstcontributions/matro. DO NOT EDIT.

package mongo

import (
	"context"
	"errors"
	"time"

	"github.com/firstcontributions/backend/internal/models/usersstore"
	"github.com/firstcontributions/backend/internal/models/utils"
	"github.com/firstcontributions/backend/pkg/cursor"
	"github.com/gokultp/go-mongoqb"
	"github.com/google/uuid"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func userFiltersToQuery(filters *usersstore.UserFilters) *mongoqb.QueryBuilder {
	qb := mongoqb.NewQueryBuilder()
	if len(filters.Ids) > 0 {
		qb.In("_id", filters.Ids)
	}
	if filters.Handle != nil {
		qb.Eq("handle", filters.Handle)
	}
	if filters.Search != nil {
		qb.Search(*filters.Search)
	}
	return qb
}
func (s *UsersStore) CreateUser(ctx context.Context, user *usersstore.User) (*usersstore.User, error) {
	now := time.Now()
	user.TimeCreated = now
	user.TimeUpdated = now
	uuid, err := uuid.NewUUID()
	if err != nil {
		return nil, err
	}
	user.Id = uuid.String()
	if _, err := s.getCollection(CollectionUsers).InsertOne(ctx, user); err != nil {
		return nil, err
	}
	return user, nil
}

func (s *UsersStore) GetUserByID(ctx context.Context, id string) (*usersstore.User, error) {
	qb := mongoqb.NewQueryBuilder().
		Eq("_id", id)
	var user usersstore.User
	if err := s.getCollection(CollectionUsers).FindOne(ctx, qb.Build()).Decode(&user); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, nil
		}
		return nil, err
	}
	return &user, nil
}

func (s *UsersStore) GetOneUser(ctx context.Context, filters *usersstore.UserFilters) (*usersstore.User, error) {
	qb := userFiltersToQuery(filters)
	var user usersstore.User
	if err := s.getCollection(CollectionUsers).FindOne(ctx, qb.Build()).Decode(&user); err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, nil
		}
		return nil, err
	}
	return &user, nil
}

func (s *UsersStore) CountUsers(ctx context.Context, filters *usersstore.UserFilters) (
	int64,
	error,
) {
	qb := userFiltersToQuery(filters)

	count, err := s.getCollection(CollectionUsers).CountDocuments(ctx, qb.Build())
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (s *UsersStore) GetUsers(
	ctx context.Context,
	filters *usersstore.UserFilters,
	after *string,
	before *string,
	first *int64,
	last *int64,
	sortBy *string,
	sortOrder *string,
) (
	[]*usersstore.User,
	bool,
	bool,
	string,
	string,
	error,
) {
	qb := userFiltersToQuery(filters)

	limit, order, cursorStr := utils.GetLimitAndSortOrderAndCursor(first, last, after, before)
	var c *cursor.Cursor
	if cursorStr != nil {
		c = cursor.FromString(*cursorStr)
		if c != nil {
			if order == 1 {
				qb.Lte("time_created", c.OffsetValue)
				qb.Lte("_id", c.ID)
			} else {
				qb.Gte("time_created", c.OffsetValue)
				qb.Gte("_id", c.ID)
			}
		}
	}
	// incrementing limit by 2 to check if next, prev elements are present
	limit += 2
	options := &options.FindOptions{
		Limit: &limit,
		Sort:  utils.GetSortOrder(sortBy, sortOrder, order),
	}

	var firstCursor, lastCursor string
	var hasNextPage, hasPreviousPage bool

	var users []*usersstore.User
	mongoCursor, err := s.getCollection(CollectionUsers).Find(ctx, qb.Build(), options)
	if err != nil {
		return nil, hasNextPage, hasPreviousPage, firstCursor, lastCursor, err
	}
	err = mongoCursor.All(ctx, &users)
	if err != nil {
		return nil, hasNextPage, hasPreviousPage, firstCursor, lastCursor, err
	}
	count := len(users)
	if count == 0 {
		return users, hasNextPage, hasPreviousPage, firstCursor, lastCursor, nil
	}

	// check if the cursor element present, if yes that can be a prev elem
	if c != nil && users[0].Id == c.ID {
		hasPreviousPage = true
		users = users[1:]
		count--
	}

	// check if actual limit +1 elements are there, if yes trim it to limit
	if count >= int(limit)-1 {
		hasNextPage = true
		users = users[:limit-2]
		count = len(users)
	}

	if count > 0 {
		firstCursor = cursor.NewCursor(users[0].Id, "time_created", users[0].TimeCreated).String()
		lastCursor = cursor.NewCursor(users[count-1].Id, "time_created", users[count-1].TimeCreated).String()
	}
	if order < 0 {
		hasNextPage, hasPreviousPage = hasPreviousPage, hasNextPage
		firstCursor, lastCursor = lastCursor, firstCursor
		users = utils.ReverseList(users)
	}
	return users, hasNextPage, hasPreviousPage, firstCursor, lastCursor, nil
}

func (s *UsersStore) UpdateUser(ctx context.Context, id string, userUpdate *usersstore.UserUpdate) error {
	qb := mongoqb.NewQueryBuilder().
		Eq("_id", id)

	now := time.Now()
	userUpdate.TimeUpdated = &now

	u := mongoqb.NewUpdateMap().
		SetFields(userUpdate)

	um, err := u.BuildUpdate()
	if err != nil {
		return err
	}
	if _, err := s.getCollection(CollectionUsers).UpdateOne(ctx, qb.Build(), um); err != nil {
		return err
	}
	return nil
}

func (s *UsersStore) DeleteUserByID(ctx context.Context, id string) error {
	qb := mongoqb.NewQueryBuilder().
		Eq("_id", id)
	if _, err := s.getCollection(CollectionUsers).DeleteOne(ctx, qb.Build()); err != nil {
		return err
	}
	return nil
}
